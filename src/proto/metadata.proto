syntax = "proto3";

package relationalai.protocol;
// If these pages ever get too big for the protobuf library, we may want to consider
// some of the suggestions here: https://developers.google.com/protocol-buffers/docs/techniques

import "schema.proto";

// wrapper for all metadata pages
message MetadataPage {
    // optional; not present for pure diff pages
    RAIDatabase db_root = 1;

    Diff diff = 2;
}

// named RAIDatabase to not conflict with the RAI.Database namespace.
message RAIDatabase {
    // Currently on version 1.
    // This is only needed at the top level (i.e., on a database page instead of diff pages)
    // because on any major version change we should rewrite the whole thing instead of leaving
    // dangling old-format pages. This lets us eventually clean up the old codepaths instead of
    // leaving migration logic around forever.
    int64 metadata_format_version = 1;

    MetadataNode root = 2;

    // ws_context in Julia. if we ever need to keep more workspace-related things, we should
    // consider moving all of it to a containing proto message.
    int64 entity_counter = 3;

    // consider including metadata like creation timestamp, created_by, etc

    // expect to include encryption keys for database when that's implemented
    // alternative: put it on a separate page so it isn't persisted every time the db is updated
}

// MetadataNodes represent the tree structure of incremental diffs, and correspond to the
// Database.MetadataNode struct.
message MetadataNode {
    int64 capacity = 1;
    int64 leafcount = 2;

    // If Page is present, then children must be empty 
    // and vice versa.
    PageId consolidated = 3;
    repeated MetadataNode children = 4;
}

// In RAI, a PageId is 128-bit but this may change in the future 
message PageId {
    RelUInt128 pid = 1;
}

message RelationData {
    // Only one of betree or inline should exist
    BeTreeRelation betree = 3;
    InlineRelation inline = 4;
}

message BeTreeRelation {
    PageId root = 1;
    int64 element_count = 2;
    int64 tree_height = 3;
}

// Diffs

// This corresponds to SerializedTipOrDiff, but leaving out the 'Tip'
// related fields, which are now separate.
message Diff {
    // next available: 7

    // Version string for RAI, used to detect when we are restoring
    // from a possibly outdated RAI version with different 
    // object layouts for derived data.
    string rai_server_version = 1;

    // version_interval in SerializedTipOrDiff
    int64 database_version_min = 2;
    int64 database_version_max = 3;

    // Arroyo SnapshotDiff for input key/values.
    InputDiff inputs = 4;

    SourceInputDiff source_inputs = 5;

    // Arroyo SnapshotDiff for derived key/values. Julia-serialized, discarded on rai-server version change.
    DerivedDiff derived = 6;
}

// Source inputs are not intended to be kept around forever, so we store them separately from relation inputs.
// This should make it easier to rip them out later as part of #7773.
message SourceInputDiff {
    repeated Source source_updates = 1;

    // names of deleted sources
    repeated string source_deletes = 2;
}

message Source {
    string name = 1;
    string value = 2;
}

// We do not plan to store any inputs that are not relations
message InputDiff {
    // Note: need to separately enforce uniqueness (updates and deletes must be disjoint)
    repeated Relation edb_updates = 1;
    repeated RelationId edb_deletes = 2;
}

// DerivedDiff is treated as binary for now.
// Possibly we could separate IDB relations?
message DerivedDiff {
    bytes serialization = 1;
}

// Relation, types
message Relation {
    RelationId id = 1;

    // Currently only contains the RelKey FD
    repeated FunctionalDependency functional_dependencies = 2;

    RelationData relation_data = 3;
    StorageConfig storage_config = 4;
}

message StorageConfig {
    // for inline relations, the storage config is empty
    bool is_empty = 1;

    // otherwise, the betree config describes how the paged data is stored
    BeTreeConfig be_tree_config = 2;
}

message BeTreeConfig {
    double epsilon = 1;
    int64 max_pivots = 2;
    int64 max_deltas = 3;
    int64 max_leaf = 4;
}

message FunctionalDependency {
    repeated int32 key_indexes = 1;
    repeated int32 value_indexes = 2;
}

message InlineRelation {
    // We only expect to inline relatively small relations, so we store data tuple-wise.
    // The types are specified in the relation id.
    repeated RelTuple tuples = 1;

    // The hash field of an inline relation is used to check equality of inline relations.
    // by preserving it here, we preserve the effective identifier over the lifetime of
    // this relation, which is necessary for the verify_metadata_roundtrip checks to pass.
    uint64 hash = 2;
}

