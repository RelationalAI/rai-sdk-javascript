// @generated by protobuf-ts 2.7.0
// @generated from protobuf file "metadata.proto" (package "relationalai.protocol", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { RelTuple } from "./schema";
import { RelationId } from "./schema";
import { RelUInt128 } from "./schema";
/**
 * wrapper for all metadata pages
 *
 * @generated from protobuf message relationalai.protocol.MetadataPage
 */
export interface MetadataPage {
    /**
     * optional; not present for pure diff pages
     *
     * @generated from protobuf field: relationalai.protocol.RAIDatabase db_root = 1;
     */
    dbRoot?: RAIDatabase;
    /**
     * @generated from protobuf field: relationalai.protocol.Diff diff = 2;
     */
    diff?: Diff;
}
/**
 * named RAIDatabase to not conflict with the RAI.Database namespace.
 *
 * @generated from protobuf message relationalai.protocol.RAIDatabase
 */
export interface RAIDatabase {
    /**
     * Currently on version 1.
     * This is only needed at the top level (i.e., on a database page instead of diff pages)
     * because on any major version change we should rewrite the whole thing instead of leaving
     * dangling old-format pages. This lets us eventually clean up the old codepaths instead of
     * leaving migration logic around forever.
     *
     * @generated from protobuf field: int64 metadata_format_version = 1;
     */
    metadataFormatVersion: bigint;
    /**
     * @generated from protobuf field: relationalai.protocol.MetadataNode root = 2;
     */
    root?: MetadataNode;
    /**
     * ws_context in Julia. if we ever need to keep more workspace-related things, we should
     * consider moving all of it to a containing proto message.
     *
     * @generated from protobuf field: int64 entity_counter = 3;
     */
    entityCounter: bigint;
}
/**
 * MetadataNodes represent the tree structure of incremental diffs, and correspond to the
 * Database.MetadataNode struct.
 *
 * @generated from protobuf message relationalai.protocol.MetadataNode
 */
export interface MetadataNode {
    /**
     * @generated from protobuf field: int64 capacity = 1;
     */
    capacity: bigint;
    /**
     * @generated from protobuf field: int64 leafcount = 2;
     */
    leafcount: bigint;
    /**
     * If Page is present, then children must be empty
     * and vice versa.
     *
     * @generated from protobuf field: relationalai.protocol.PageId consolidated = 3;
     */
    consolidated?: PageId;
    /**
     * @generated from protobuf field: repeated relationalai.protocol.MetadataNode children = 4;
     */
    children: MetadataNode[];
}
/**
 * In RAI, a PageId is 128-bit but this may change in the future
 *
 * @generated from protobuf message relationalai.protocol.PageId
 */
export interface PageId {
    /**
     * @generated from protobuf field: relationalai.protocol.RelUInt128 pid = 1;
     */
    pid?: RelUInt128;
}
/**
 * @generated from protobuf message relationalai.protocol.RelationData
 */
export interface RelationData {
    /**
     * Only one of betree or inline should exist
     *
     * @generated from protobuf field: relationalai.protocol.BeTreeRelation betree = 3;
     */
    betree?: BeTreeRelation;
    /**
     * @generated from protobuf field: relationalai.protocol.InlineRelation inline = 4;
     */
    inline?: InlineRelation;
}
/**
 * @generated from protobuf message relationalai.protocol.BeTreeRelation
 */
export interface BeTreeRelation {
    /**
     * @generated from protobuf field: relationalai.protocol.PageId root = 1;
     */
    root?: PageId;
    /**
     * @generated from protobuf field: int64 element_count = 2;
     */
    elementCount: bigint;
    /**
     * @generated from protobuf field: int64 tree_height = 3;
     */
    treeHeight: bigint;
}
// Diffs

/**
 * This corresponds to SerializedTipOrDiff, but leaving out the 'Tip'
 * related fields, which are now separate.
 *
 * next available: 7
 *
 * @generated from protobuf message relationalai.protocol.Diff
 */
export interface Diff {
    /**
     * Version string for RAI, used to detect when we are restoring
     * from a possibly outdated RAI version with different
     * object layouts for derived data.
     *
     * @generated from protobuf field: string rai_server_version = 1;
     */
    raiServerVersion: string;
    /**
     * version_interval in SerializedTipOrDiff
     *
     * @generated from protobuf field: int64 database_version_min = 2;
     */
    databaseVersionMin: bigint;
    /**
     * @generated from protobuf field: int64 database_version_max = 3;
     */
    databaseVersionMax: bigint;
    /**
     * Arroyo SnapshotDiff for input key/values.
     *
     * @generated from protobuf field: relationalai.protocol.InputDiff inputs = 4;
     */
    inputs?: InputDiff;
    /**
     * @generated from protobuf field: relationalai.protocol.SourceInputDiff source_inputs = 5;
     */
    sourceInputs?: SourceInputDiff;
    /**
     * Arroyo SnapshotDiff for derived key/values. Julia-serialized, discarded on rai-server version change.
     *
     * @generated from protobuf field: relationalai.protocol.DerivedDiff derived = 6;
     */
    derived?: DerivedDiff;
}
/**
 * Source inputs are not intended to be kept around forever, so we store them separately from relation inputs.
 * This should make it easier to rip them out later as part of #7773.
 *
 * @generated from protobuf message relationalai.protocol.SourceInputDiff
 */
export interface SourceInputDiff {
    /**
     * @generated from protobuf field: repeated relationalai.protocol.Source source_updates = 1;
     */
    sourceUpdates: Source[];
    /**
     * names of deleted sources
     *
     * @generated from protobuf field: repeated string source_deletes = 2;
     */
    sourceDeletes: string[];
}
/**
 * @generated from protobuf message relationalai.protocol.Source
 */
export interface Source {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string value = 2;
     */
    value: string;
}
/**
 * We do not plan to store any inputs that are not relations
 *
 * @generated from protobuf message relationalai.protocol.InputDiff
 */
export interface InputDiff {
    /**
     * Note: need to separately enforce uniqueness (updates and deletes must be disjoint)
     *
     * @generated from protobuf field: repeated relationalai.protocol.Relation edb_updates = 1;
     */
    edbUpdates: Relation[];
    /**
     * @generated from protobuf field: repeated relationalai.protocol.RelationId edb_deletes = 2;
     */
    edbDeletes: RelationId[];
}
/**
 * DerivedDiff is treated as binary for now.
 * Possibly we could separate IDB relations?
 *
 * @generated from protobuf message relationalai.protocol.DerivedDiff
 */
export interface DerivedDiff {
    /**
     * @generated from protobuf field: bytes serialization = 1;
     */
    serialization: Uint8Array;
}
/**
 * Relation, types
 *
 * @generated from protobuf message relationalai.protocol.Relation
 */
export interface Relation {
    /**
     * @generated from protobuf field: relationalai.protocol.RelationId id = 1;
     */
    id?: RelationId;
    /**
     * Currently only contains the RelKey FD
     *
     * @generated from protobuf field: repeated relationalai.protocol.FunctionalDependency functional_dependencies = 2;
     */
    functionalDependencies: FunctionalDependency[];
    /**
     * @generated from protobuf field: relationalai.protocol.RelationData relation_data = 3;
     */
    relationData?: RelationData;
    /**
     * @generated from protobuf field: relationalai.protocol.StorageConfig storage_config = 4;
     */
    storageConfig?: StorageConfig;
}
/**
 * @generated from protobuf message relationalai.protocol.StorageConfig
 */
export interface StorageConfig {
    /**
     * for inline relations, the storage config is empty
     *
     * @generated from protobuf field: bool is_empty = 1;
     */
    isEmpty: boolean;
    /**
     * otherwise, the betree config describes how the paged data is stored
     *
     * @generated from protobuf field: relationalai.protocol.BeTreeConfig be_tree_config = 2;
     */
    beTreeConfig?: BeTreeConfig;
}
/**
 * @generated from protobuf message relationalai.protocol.BeTreeConfig
 */
export interface BeTreeConfig {
    /**
     * @generated from protobuf field: double epsilon = 1;
     */
    epsilon: number;
    /**
     * @generated from protobuf field: int64 max_pivots = 2;
     */
    maxPivots: bigint;
    /**
     * @generated from protobuf field: int64 max_deltas = 3;
     */
    maxDeltas: bigint;
    /**
     * @generated from protobuf field: int64 max_leaf = 4;
     */
    maxLeaf: bigint;
}
/**
 * @generated from protobuf message relationalai.protocol.FunctionalDependency
 */
export interface FunctionalDependency {
    /**
     * @generated from protobuf field: repeated int32 key_indexes = 1;
     */
    keyIndexes: number[];
    /**
     * @generated from protobuf field: repeated int32 value_indexes = 2;
     */
    valueIndexes: number[];
}
/**
 * @generated from protobuf message relationalai.protocol.InlineRelation
 */
export interface InlineRelation {
    /**
     * We only expect to inline relatively small relations, so we store data tuple-wise.
     * The types are specified in the relation id.
     *
     * @generated from protobuf field: repeated relationalai.protocol.RelTuple tuples = 1;
     */
    tuples: RelTuple[];
    /**
     * The hash field of an inline relation is used to check equality of inline relations.
     * by preserving it here, we preserve the effective identifier over the lifetime of
     * this relation, which is necessary for the verify_metadata_roundtrip checks to pass.
     *
     * @generated from protobuf field: uint64 hash = 2;
     */
    hash: bigint;
}
// @generated message type with reflection information, may provide speed optimized methods
class MetadataPage$Type extends MessageType<MetadataPage> {
    constructor() {
        super("relationalai.protocol.MetadataPage", [
            { no: 1, name: "db_root", kind: "message", T: () => RAIDatabase },
            { no: 2, name: "diff", kind: "message", T: () => Diff }
        ]);
    }
    create(value?: PartialMessage<MetadataPage>): MetadataPage {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MetadataPage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MetadataPage): MetadataPage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* relationalai.protocol.RAIDatabase db_root */ 1:
                    message.dbRoot = RAIDatabase.internalBinaryRead(reader, reader.uint32(), options, message.dbRoot);
                    break;
                case /* relationalai.protocol.Diff diff */ 2:
                    message.diff = Diff.internalBinaryRead(reader, reader.uint32(), options, message.diff);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MetadataPage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* relationalai.protocol.RAIDatabase db_root = 1; */
        if (message.dbRoot)
            RAIDatabase.internalBinaryWrite(message.dbRoot, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* relationalai.protocol.Diff diff = 2; */
        if (message.diff)
            Diff.internalBinaryWrite(message.diff, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message relationalai.protocol.MetadataPage
 */
export const MetadataPage = new MetadataPage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RAIDatabase$Type extends MessageType<RAIDatabase> {
    constructor() {
        super("relationalai.protocol.RAIDatabase", [
            { no: 1, name: "metadata_format_version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "root", kind: "message", T: () => MetadataNode },
            { no: 3, name: "entity_counter", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<RAIDatabase>): RAIDatabase {
        const message = { metadataFormatVersion: 0n, entityCounter: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RAIDatabase>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RAIDatabase): RAIDatabase {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 metadata_format_version */ 1:
                    message.metadataFormatVersion = reader.int64().toBigInt();
                    break;
                case /* relationalai.protocol.MetadataNode root */ 2:
                    message.root = MetadataNode.internalBinaryRead(reader, reader.uint32(), options, message.root);
                    break;
                case /* int64 entity_counter */ 3:
                    message.entityCounter = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RAIDatabase, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 metadata_format_version = 1; */
        if (message.metadataFormatVersion !== 0n)
            writer.tag(1, WireType.Varint).int64(message.metadataFormatVersion);
        /* relationalai.protocol.MetadataNode root = 2; */
        if (message.root)
            MetadataNode.internalBinaryWrite(message.root, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int64 entity_counter = 3; */
        if (message.entityCounter !== 0n)
            writer.tag(3, WireType.Varint).int64(message.entityCounter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message relationalai.protocol.RAIDatabase
 */
export const RAIDatabase = new RAIDatabase$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MetadataNode$Type extends MessageType<MetadataNode> {
    constructor() {
        super("relationalai.protocol.MetadataNode", [
            { no: 1, name: "capacity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "leafcount", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "consolidated", kind: "message", T: () => PageId },
            { no: 4, name: "children", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MetadataNode }
        ]);
    }
    create(value?: PartialMessage<MetadataNode>): MetadataNode {
        const message = { capacity: 0n, leafcount: 0n, children: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MetadataNode>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MetadataNode): MetadataNode {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 capacity */ 1:
                    message.capacity = reader.int64().toBigInt();
                    break;
                case /* int64 leafcount */ 2:
                    message.leafcount = reader.int64().toBigInt();
                    break;
                case /* relationalai.protocol.PageId consolidated */ 3:
                    message.consolidated = PageId.internalBinaryRead(reader, reader.uint32(), options, message.consolidated);
                    break;
                case /* repeated relationalai.protocol.MetadataNode children */ 4:
                    message.children.push(MetadataNode.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MetadataNode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 capacity = 1; */
        if (message.capacity !== 0n)
            writer.tag(1, WireType.Varint).int64(message.capacity);
        /* int64 leafcount = 2; */
        if (message.leafcount !== 0n)
            writer.tag(2, WireType.Varint).int64(message.leafcount);
        /* relationalai.protocol.PageId consolidated = 3; */
        if (message.consolidated)
            PageId.internalBinaryWrite(message.consolidated, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated relationalai.protocol.MetadataNode children = 4; */
        for (let i = 0; i < message.children.length; i++)
            MetadataNode.internalBinaryWrite(message.children[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message relationalai.protocol.MetadataNode
 */
export const MetadataNode = new MetadataNode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PageId$Type extends MessageType<PageId> {
    constructor() {
        super("relationalai.protocol.PageId", [
            { no: 1, name: "pid", kind: "message", T: () => RelUInt128 }
        ]);
    }
    create(value?: PartialMessage<PageId>): PageId {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PageId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PageId): PageId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* relationalai.protocol.RelUInt128 pid */ 1:
                    message.pid = RelUInt128.internalBinaryRead(reader, reader.uint32(), options, message.pid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PageId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* relationalai.protocol.RelUInt128 pid = 1; */
        if (message.pid)
            RelUInt128.internalBinaryWrite(message.pid, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message relationalai.protocol.PageId
 */
export const PageId = new PageId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelationData$Type extends MessageType<RelationData> {
    constructor() {
        super("relationalai.protocol.RelationData", [
            { no: 3, name: "betree", kind: "message", T: () => BeTreeRelation },
            { no: 4, name: "inline", kind: "message", T: () => InlineRelation }
        ]);
    }
    create(value?: PartialMessage<RelationData>): RelationData {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RelationData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelationData): RelationData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* relationalai.protocol.BeTreeRelation betree */ 3:
                    message.betree = BeTreeRelation.internalBinaryRead(reader, reader.uint32(), options, message.betree);
                    break;
                case /* relationalai.protocol.InlineRelation inline */ 4:
                    message.inline = InlineRelation.internalBinaryRead(reader, reader.uint32(), options, message.inline);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelationData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* relationalai.protocol.BeTreeRelation betree = 3; */
        if (message.betree)
            BeTreeRelation.internalBinaryWrite(message.betree, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* relationalai.protocol.InlineRelation inline = 4; */
        if (message.inline)
            InlineRelation.internalBinaryWrite(message.inline, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message relationalai.protocol.RelationData
 */
export const RelationData = new RelationData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BeTreeRelation$Type extends MessageType<BeTreeRelation> {
    constructor() {
        super("relationalai.protocol.BeTreeRelation", [
            { no: 1, name: "root", kind: "message", T: () => PageId },
            { no: 2, name: "element_count", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "tree_height", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<BeTreeRelation>): BeTreeRelation {
        const message = { elementCount: 0n, treeHeight: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BeTreeRelation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BeTreeRelation): BeTreeRelation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* relationalai.protocol.PageId root */ 1:
                    message.root = PageId.internalBinaryRead(reader, reader.uint32(), options, message.root);
                    break;
                case /* int64 element_count */ 2:
                    message.elementCount = reader.int64().toBigInt();
                    break;
                case /* int64 tree_height */ 3:
                    message.treeHeight = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BeTreeRelation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* relationalai.protocol.PageId root = 1; */
        if (message.root)
            PageId.internalBinaryWrite(message.root, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 element_count = 2; */
        if (message.elementCount !== 0n)
            writer.tag(2, WireType.Varint).int64(message.elementCount);
        /* int64 tree_height = 3; */
        if (message.treeHeight !== 0n)
            writer.tag(3, WireType.Varint).int64(message.treeHeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message relationalai.protocol.BeTreeRelation
 */
export const BeTreeRelation = new BeTreeRelation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Diff$Type extends MessageType<Diff> {
    constructor() {
        super("relationalai.protocol.Diff", [
            { no: 1, name: "rai_server_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "database_version_min", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "database_version_max", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "inputs", kind: "message", T: () => InputDiff },
            { no: 5, name: "source_inputs", kind: "message", T: () => SourceInputDiff },
            { no: 6, name: "derived", kind: "message", T: () => DerivedDiff }
        ]);
    }
    create(value?: PartialMessage<Diff>): Diff {
        const message = { raiServerVersion: "", databaseVersionMin: 0n, databaseVersionMax: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Diff>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Diff): Diff {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string rai_server_version */ 1:
                    message.raiServerVersion = reader.string();
                    break;
                case /* int64 database_version_min */ 2:
                    message.databaseVersionMin = reader.int64().toBigInt();
                    break;
                case /* int64 database_version_max */ 3:
                    message.databaseVersionMax = reader.int64().toBigInt();
                    break;
                case /* relationalai.protocol.InputDiff inputs */ 4:
                    message.inputs = InputDiff.internalBinaryRead(reader, reader.uint32(), options, message.inputs);
                    break;
                case /* relationalai.protocol.SourceInputDiff source_inputs */ 5:
                    message.sourceInputs = SourceInputDiff.internalBinaryRead(reader, reader.uint32(), options, message.sourceInputs);
                    break;
                case /* relationalai.protocol.DerivedDiff derived */ 6:
                    message.derived = DerivedDiff.internalBinaryRead(reader, reader.uint32(), options, message.derived);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Diff, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string rai_server_version = 1; */
        if (message.raiServerVersion !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.raiServerVersion);
        /* int64 database_version_min = 2; */
        if (message.databaseVersionMin !== 0n)
            writer.tag(2, WireType.Varint).int64(message.databaseVersionMin);
        /* int64 database_version_max = 3; */
        if (message.databaseVersionMax !== 0n)
            writer.tag(3, WireType.Varint).int64(message.databaseVersionMax);
        /* relationalai.protocol.InputDiff inputs = 4; */
        if (message.inputs)
            InputDiff.internalBinaryWrite(message.inputs, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* relationalai.protocol.SourceInputDiff source_inputs = 5; */
        if (message.sourceInputs)
            SourceInputDiff.internalBinaryWrite(message.sourceInputs, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* relationalai.protocol.DerivedDiff derived = 6; */
        if (message.derived)
            DerivedDiff.internalBinaryWrite(message.derived, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message relationalai.protocol.Diff
 */
export const Diff = new Diff$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SourceInputDiff$Type extends MessageType<SourceInputDiff> {
    constructor() {
        super("relationalai.protocol.SourceInputDiff", [
            { no: 1, name: "source_updates", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Source },
            { no: 2, name: "source_deletes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SourceInputDiff>): SourceInputDiff {
        const message = { sourceUpdates: [], sourceDeletes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SourceInputDiff>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SourceInputDiff): SourceInputDiff {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated relationalai.protocol.Source source_updates */ 1:
                    message.sourceUpdates.push(Source.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string source_deletes */ 2:
                    message.sourceDeletes.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SourceInputDiff, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated relationalai.protocol.Source source_updates = 1; */
        for (let i = 0; i < message.sourceUpdates.length; i++)
            Source.internalBinaryWrite(message.sourceUpdates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string source_deletes = 2; */
        for (let i = 0; i < message.sourceDeletes.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.sourceDeletes[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message relationalai.protocol.SourceInputDiff
 */
export const SourceInputDiff = new SourceInputDiff$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Source$Type extends MessageType<Source> {
    constructor() {
        super("relationalai.protocol.Source", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Source>): Source {
        const message = { name: "", value: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Source>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Source): Source {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Source, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message relationalai.protocol.Source
 */
export const Source = new Source$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InputDiff$Type extends MessageType<InputDiff> {
    constructor() {
        super("relationalai.protocol.InputDiff", [
            { no: 1, name: "edb_updates", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Relation },
            { no: 2, name: "edb_deletes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RelationId }
        ]);
    }
    create(value?: PartialMessage<InputDiff>): InputDiff {
        const message = { edbUpdates: [], edbDeletes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InputDiff>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InputDiff): InputDiff {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated relationalai.protocol.Relation edb_updates */ 1:
                    message.edbUpdates.push(Relation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated relationalai.protocol.RelationId edb_deletes */ 2:
                    message.edbDeletes.push(RelationId.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InputDiff, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated relationalai.protocol.Relation edb_updates = 1; */
        for (let i = 0; i < message.edbUpdates.length; i++)
            Relation.internalBinaryWrite(message.edbUpdates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated relationalai.protocol.RelationId edb_deletes = 2; */
        for (let i = 0; i < message.edbDeletes.length; i++)
            RelationId.internalBinaryWrite(message.edbDeletes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message relationalai.protocol.InputDiff
 */
export const InputDiff = new InputDiff$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivedDiff$Type extends MessageType<DerivedDiff> {
    constructor() {
        super("relationalai.protocol.DerivedDiff", [
            { no: 1, name: "serialization", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<DerivedDiff>): DerivedDiff {
        const message = { serialization: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DerivedDiff>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivedDiff): DerivedDiff {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes serialization */ 1:
                    message.serialization = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivedDiff, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes serialization = 1; */
        if (message.serialization.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.serialization);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message relationalai.protocol.DerivedDiff
 */
export const DerivedDiff = new DerivedDiff$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Relation$Type extends MessageType<Relation> {
    constructor() {
        super("relationalai.protocol.Relation", [
            { no: 1, name: "id", kind: "message", T: () => RelationId },
            { no: 2, name: "functional_dependencies", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FunctionalDependency },
            { no: 3, name: "relation_data", kind: "message", T: () => RelationData },
            { no: 4, name: "storage_config", kind: "message", T: () => StorageConfig }
        ]);
    }
    create(value?: PartialMessage<Relation>): Relation {
        const message = { functionalDependencies: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Relation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Relation): Relation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* relationalai.protocol.RelationId id */ 1:
                    message.id = RelationId.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                case /* repeated relationalai.protocol.FunctionalDependency functional_dependencies */ 2:
                    message.functionalDependencies.push(FunctionalDependency.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* relationalai.protocol.RelationData relation_data */ 3:
                    message.relationData = RelationData.internalBinaryRead(reader, reader.uint32(), options, message.relationData);
                    break;
                case /* relationalai.protocol.StorageConfig storage_config */ 4:
                    message.storageConfig = StorageConfig.internalBinaryRead(reader, reader.uint32(), options, message.storageConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Relation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* relationalai.protocol.RelationId id = 1; */
        if (message.id)
            RelationId.internalBinaryWrite(message.id, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated relationalai.protocol.FunctionalDependency functional_dependencies = 2; */
        for (let i = 0; i < message.functionalDependencies.length; i++)
            FunctionalDependency.internalBinaryWrite(message.functionalDependencies[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* relationalai.protocol.RelationData relation_data = 3; */
        if (message.relationData)
            RelationData.internalBinaryWrite(message.relationData, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* relationalai.protocol.StorageConfig storage_config = 4; */
        if (message.storageConfig)
            StorageConfig.internalBinaryWrite(message.storageConfig, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message relationalai.protocol.Relation
 */
export const Relation = new Relation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StorageConfig$Type extends MessageType<StorageConfig> {
    constructor() {
        super("relationalai.protocol.StorageConfig", [
            { no: 1, name: "is_empty", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "be_tree_config", kind: "message", T: () => BeTreeConfig }
        ]);
    }
    create(value?: PartialMessage<StorageConfig>): StorageConfig {
        const message = { isEmpty: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StorageConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StorageConfig): StorageConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_empty */ 1:
                    message.isEmpty = reader.bool();
                    break;
                case /* relationalai.protocol.BeTreeConfig be_tree_config */ 2:
                    message.beTreeConfig = BeTreeConfig.internalBinaryRead(reader, reader.uint32(), options, message.beTreeConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StorageConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_empty = 1; */
        if (message.isEmpty !== false)
            writer.tag(1, WireType.Varint).bool(message.isEmpty);
        /* relationalai.protocol.BeTreeConfig be_tree_config = 2; */
        if (message.beTreeConfig)
            BeTreeConfig.internalBinaryWrite(message.beTreeConfig, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message relationalai.protocol.StorageConfig
 */
export const StorageConfig = new StorageConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BeTreeConfig$Type extends MessageType<BeTreeConfig> {
    constructor() {
        super("relationalai.protocol.BeTreeConfig", [
            { no: 1, name: "epsilon", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "max_pivots", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "max_deltas", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "max_leaf", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<BeTreeConfig>): BeTreeConfig {
        const message = { epsilon: 0, maxPivots: 0n, maxDeltas: 0n, maxLeaf: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BeTreeConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BeTreeConfig): BeTreeConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double epsilon */ 1:
                    message.epsilon = reader.double();
                    break;
                case /* int64 max_pivots */ 2:
                    message.maxPivots = reader.int64().toBigInt();
                    break;
                case /* int64 max_deltas */ 3:
                    message.maxDeltas = reader.int64().toBigInt();
                    break;
                case /* int64 max_leaf */ 4:
                    message.maxLeaf = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BeTreeConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double epsilon = 1; */
        if (message.epsilon !== 0)
            writer.tag(1, WireType.Bit64).double(message.epsilon);
        /* int64 max_pivots = 2; */
        if (message.maxPivots !== 0n)
            writer.tag(2, WireType.Varint).int64(message.maxPivots);
        /* int64 max_deltas = 3; */
        if (message.maxDeltas !== 0n)
            writer.tag(3, WireType.Varint).int64(message.maxDeltas);
        /* int64 max_leaf = 4; */
        if (message.maxLeaf !== 0n)
            writer.tag(4, WireType.Varint).int64(message.maxLeaf);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message relationalai.protocol.BeTreeConfig
 */
export const BeTreeConfig = new BeTreeConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FunctionalDependency$Type extends MessageType<FunctionalDependency> {
    constructor() {
        super("relationalai.protocol.FunctionalDependency", [
            { no: 1, name: "key_indexes", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "value_indexes", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<FunctionalDependency>): FunctionalDependency {
        const message = { keyIndexes: [], valueIndexes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FunctionalDependency>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FunctionalDependency): FunctionalDependency {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 key_indexes */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.keyIndexes.push(reader.int32());
                    else
                        message.keyIndexes.push(reader.int32());
                    break;
                case /* repeated int32 value_indexes */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.valueIndexes.push(reader.int32());
                    else
                        message.valueIndexes.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FunctionalDependency, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 key_indexes = 1; */
        if (message.keyIndexes.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.keyIndexes.length; i++)
                writer.int32(message.keyIndexes[i]);
            writer.join();
        }
        /* repeated int32 value_indexes = 2; */
        if (message.valueIndexes.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.valueIndexes.length; i++)
                writer.int32(message.valueIndexes[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message relationalai.protocol.FunctionalDependency
 */
export const FunctionalDependency = new FunctionalDependency$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InlineRelation$Type extends MessageType<InlineRelation> {
    constructor() {
        super("relationalai.protocol.InlineRelation", [
            { no: 1, name: "tuples", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RelTuple },
            { no: 2, name: "hash", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<InlineRelation>): InlineRelation {
        const message = { tuples: [], hash: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InlineRelation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InlineRelation): InlineRelation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated relationalai.protocol.RelTuple tuples */ 1:
                    message.tuples.push(RelTuple.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 hash */ 2:
                    message.hash = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InlineRelation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated relationalai.protocol.RelTuple tuples = 1; */
        for (let i = 0; i < message.tuples.length; i++)
            RelTuple.internalBinaryWrite(message.tuples[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 hash = 2; */
        if (message.hash !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.hash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message relationalai.protocol.InlineRelation
 */
export const InlineRelation = new InlineRelation$Type();
